'use strict'


function testString2Int(s){
//   if(s.length) > 1 {
//     var arr;
//     for(var i = 0; i < s.length; i++){
//       arr.push(i);
//     }
//     return arr.map(function(x){return s[i]*1;}).reduce(function(x,y){return x*10+y;});
//   }else if(s.length == 1){
//     return s[0]*1;
//   }
//   return null;
  return Array.prototype.map.call(s,function(x){return x*1;}).reduce(function(x,y){return x*10+y;});
}



//https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/submissions/
var maxProfit =  function(k, prices){
	var res = 0;
	if(k > prices.length / 2){
		for(let i = 1; i < prices.length; i++){
			if(prices[i] - prices[i-1] > 0){
				res += prices[i] - prices[i-1];
			}
		}
		return res;
	}

	var own = new Array(prices.length);
	var clear = new Array(prices.length);
	own[0] = [];
	clear[0] = [];
	for(let i = 0; i < own.length; i++){
		for(let j = 0; j < k+1; j++){
			own[i] = own[i] || [];
			clear[i] = clear[i] || [];
			if(i == 0){
				own[0][j] = 0-prices[0];
			}else{
				own[i][j] = 0;
			}
			clear[i][j] = 0;
		}
	}
	for(var i = 1; i < prices.length; i++){
		for(var j = 1; j < k+1; j++){
			clear[i] = clear[i] || [];
			own[i] = own[i] || [];
			own[i][j] = Math.max(own[i-1][j], clear[i-1][j-1]-prices[i]);
			clear[i][j] = Math.max(own[i-1][j]+prices[i],clear[i-1][j]);
		}
	}
	return clear[prices.length -1][k];
};
//there is anothe way which I have no idea;
var maxProfitNew = function(k, prices) {
    if(k<=0||prices.length<=1)
        return 0;
    /*Max Profit on any number of transactions*/
    let mxPr = function(ar){
        let sum=0;
        for(let i=1;i<ar.length;i++)
            sum+=Math.max(0,ar[i]-ar[i-1]);
        return sum;
    }
    
    if(k>=prices.length)
        return mxPr(prices);
    
    
    let dp=new Array(2);
    dp[0]=new Array(prices.length).fill(0);
    let mxdif;
    for(let i=1;i<=k;i++){
        dp[1]=new Array(prices.length).fill(0);
        mxdif=0-prices[0];
        for(let j=1;j<prices.length;j++){
            dp[1][j]=Math.max(dp[1][j-1],mxdif+prices[j]);
            mxdif=Math.max(mxdif,dp[0][j]-prices[j]);
        }
        dp.shift();
    }
    return dp[dp.length-1].pop()||0;
};
/*Heap sort*/
function heapSort(arr){
    
    let heap = arr.slice(0);
    const iLength = heap.length;
    const iLastParent = parseInt(iLength /2 - 1);
    //build the first max heap;
    for(let i = iLastParent ; i > -1; i--){
        heap = adjustHeap(heap.slice(0),i,iLength -1);
    }
    //sort the values
    for(let i = iLength - 1; i > 0 ; i --){
        [heap[0],heap[i]] = swap([heap[0],heap[i]]);
        heap = adjustHeap(heap.slice(0),0, i - 1);
    }


    return heap;
}

function swap([a,b]){
    return [b,a];

}

function adjustHeap(arr,start,end){
    let i = start,  left, right, iChange,checkVal;
    let res = arr.slice(0);
    while( i < end ){
        left = i * 2 + 1;
        right = i * 2 + 2;
        checkVal = res[i];

        if(right <= end && res[right] > checkVal){
            iChange = right;
            checkVal = res[right];
        }
        if(left <= end && res[left] > checkVal){
            iChange = left;
        }
        if(iChange !== i && !!iChange){
            [res[i],res[iChange]] = swap([res[i],res[iChange]]);
            i = iChange;
        }else{
           break;
        }
    }
    return res;
}

function crossRiver(nums){
    var res = 0;

    var needCross = nums.sort((a,b)=>{return a-b;});
    var iLength = needCross.length;
    var iNeed =  iLength, l = 0, r = iLength -1;
    while(r > -1){
        if(r === 0){
            res += needCross[l];
            r = -1;
            break; 
        }else if(r === 1){
            res += needCross[l] + needCross[r];
            r = -1;
            break;
        }else if(r === 2){
            res += needCross[l] + needCross[l + 1] + needCross[r];
            r = -1;
            break;
        }else{
            //use the smallest as switcher
            let iSmall = 2 * needCross[l] + needCross[r-1] + needCross[r];
            let iTwoSwitch = needCross[l] + 2 * needCross[l+1] + needCross[r];
            if(iSmall < iTwoSwitch){
                res += iSmall;
            }else{
                res += iTwoSwitch;
            }
            r = r - 2;
        }

    }
    return res;
}
//https://leetcode.com/problems/super-ugly-number/
var nthSuperUglyNumber = function(n, primes) {
    /*
    * idx[i] means that the smallest value for the primes[i] to multiple next time;
    * for exmaple, the first round everyone should multiple ugly[0] which is 1;
    * for the second round, ugly[1] is generated by a prime which the idx should be 1 
    * since idx 0 is used to compute ugly[1].
    */
    var idx = primes.slice(0).fill(0);
    var ugly = [1];
    while(ugly.length < n){
        var min = Number.MAX_VALUE;
        for(let j = 0; j < primes.length; j++){
            min = Math.min(min, primes[j] * ugly[idx[j]]);
        }
        ugly.push(min);
        for(let j = 0; j < primes.length; j++){
            if(ugly[idx[j]] * primes[j] === min){
                idx[j]++;
            }
        }
    }
    return ugly[n-1];
};
